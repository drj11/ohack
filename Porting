Some remarks that may be useful when you try porting hack.

This program has grown slowly but steadily for several years.
Its original version was very buggy, and debugging soon became
rewriting. The program still bears all the signs of this slow
evolution: many similar problems are solved in dissimilar ways,
which is often rather confusing. Also, the program is much less
modular than it appears to be. Be very careful when you change
a piece of code! - everything depends on everything.

When we got the program one could not play for a quarter of an
hour without getting a core dump. Now a core dump is observed
once every other month (say, once in a thousand games).

The source was written and is reasonably well tested out on
a vax with BSD4.* . Older versions of the program run on a
PDP11/45 with V7, but at present the program is much too large.
As far as I can see, there are not many hidden assumptions about
the host machine, but there might well be problems if
one cannot cast a pointer into an integer or vice versa.
It is assumed that any structure can be at the address of a long.

The dialect of C used is rather rich: we use bitfields, structure
assignments and functions returning structures.

Porting to a M68000 with V7 took about one hour ( + compilation
time) to get the program running, and two evenings to locate a
strange bug in the shopkeeper movement, that turned out to be
a bug in the local C-compiler.
One hour of editing:
	Locate all identifier pairs that have the first 7 characters
	in common, and rename.
	[Note that case is important, and that some pairs of identifiers
	 have 10 or more initial characters in common.
	 Also note that some identifiers are generated by the program
	 makedefs (such as CROSSBOW and CROSSBOW_BOLT or DEAD_GIANT_RAT
	 and DEAD_GIANT_ANT or WORTHLESS_PIECE_OF_BLUE_GLASS and
	 WORTHLESS_PIECE_OF_YELLOW_GLASS).
	 If your C-compiler distinguishes 7 or more symbols then the
	 work is annoying but doable. However, if you are the unlucky
	 one with a compiler that only retains 6 symbols, then you
	 probably should write a C-program compactifier that reads a
	 C program and outputs an equivalent program but with all tags
	 replaced by short ones (like T0, T1, ...). This is easy but
	 not entirely trivial; e.g., references to external variables
	 and routines should remain intact.]
Two evenings of digging:
	It turned out that the C-compiler on this M68000 got confused
	when there were too many variables declared register char.
	[After  register char x,y; x = 1; y = 2;  the variable x would
	 contain 0, i.e., for the assignment y = 2 a word-move was
	 generated.]
Right now this M68000 version seems to work flawlessly.
(Note that I do not distribute a M68000 version; this porting work was
 done on a machine I no longer have access to.)
